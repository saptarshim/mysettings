* Topic
** A topic is a name for a stresam of messages with a defined
** Before a node can transmit data over topic, node must first advertize both the topic name and types of messages that are going to be sent
** Node that want to receive messages on a topipc can subscribe to the message by requesting to the roscore
** All messages on the same topic must be of the same data type ( This is not enforced, let's look into exploiting this for a more flexible architecture)
** Latched Topic : Publisher can mae the publishing lathed, in that case the new subsriber will get the last message sent out by the publisher at the time of subsribing
* Message
** Create new message only if you have to. Use the command rosmsg to see the existing set of messages that is part of ROS for maximum scalability and usability
* Service
** 1 to 1 Synchronous RPC from one node to another, allowing explicit two way communication between nodes
* Actions
**Actions are the best way to implement interfaces to time extended goal oriented behaviours. Actions use a goal to initiate a behaviour
and sends a results when the bahaviour is complete.Actions also reports feedback top provide updates on behaviour's progress towards the goal
and also allow the goal to be canceled
 


******Utility Commands to deal with the ROS systems*******
* roscore
** Start the Master. We need to do this before running any ROS node. Nothing will work if master is not running
* rosrun
** rthis command is use to create a ROS node (aka execute a ros program)
** Usage: rosrun package-name executable-name __name:=node-name
* rosnode
** Usage: rosnode argument
** Argument list
*** list : List all running node
*** info node-name : return detail information about the node node-name
*** kill node-name : Kill the node node-name
*** cleanup : Remover all dead nodeas that are either crashed or killed
* rqt_graph
** Visually show the publisher and subscriber relationship between nodes
* rqt_console
** Show the rosout console in a GUI
* rostopic
** Usage : rostopic arguments
** Argument list
*** list : List the Active topics
*** echo topic-nmae : See the actualy message published on a single topic topic-name
*** hz topic-name : Show output stat of topic-nmae in unit of message/sec
*** bw topic-name : Show output stat of toipic-name in bytes/sec
*** info topic-name : Additional information on the topic
*** pub -r rate-in-hz topic-name message-type message-contents : Publis a message from a command line
* rosmsg
** Usage: rosmsg arguments
** Argument list
*** show message-type-name : Show detail information about a message type, typically we get the message type name from the rostopic info topic-nmae command
* roswtf
** Perform broad set of sanity checks, try this when stuff is not as expected under ROS

* rolsclean
** usage: rosclean argument
** Argument list
*** check : Disk space consumed by ROS in the current system
*** purge : Delete all existing logs

**************ROS Node Development related Information***************

* Steps for creating a new project workspace
** Create a project directory
** Create a directory called src inside this
** Run this command from inside just created src directoy to create a package called package_name
*** catkin_create_pkg package_name  optional-package-name that this-package-is-depend on
** Update the package.xml file created by the previous command in the package directory with the right set of information
*** Update/Add the <build_depend>package-name</build_depend> sections
*** Update the <run_depend>package-name</run_depend> sections
** Update the CMakeLists.txt in the package directory
*** Update/Add the find_package(...) tags
**** Example: find_package(catkin REQUIRED); find_package(catkin REQUIRED COMPONETS roscpp)
*** Update/Add add_executable(executable-name source-file)
**** Example:add_executable(hello hello.cpp)
*** Update/Add target_link_libraries(executable-nmae ${catkin_LIBRARIES})
**** Example: target_link_libraries(hello, ${catkin_LIBRARIES})
** excute "catkin_make" from tEhe root project directory to build the project
** execute "source devel/setup.bash, this automatically sets environment variables that enable ROS to find the developmed package and let it execute
** Execute "rosrun package-name node-name", this will execute the node
*** Example: rosrun agitr hello

* Various package and funtions related information needed to interact with ROS from a C++ node
** ros::init
*** Initialize the ROS client libraries
*** option argument
**** __ns:=default-namespace   : create a relative namespace for the node
**** we cna also use export ROS_NAMESPACE=default-namespace to assign relative default naemspace for all nodes running from a console if it';s not specified in the __ns param
*** Usage: ros::init(argc, argv, "Default-name-of-the-node");
*** Example: ros::init(argc, argv, "Hello_ros");
** ros::NodeHandle
*** Main object a node use to interact with the ROS systems. By instantiation of thie object register the node Ewith the ROS master
** ros::Publisher
*** Handle the work of publishing a messagae
*** Usage: ros::Publisher publisher-name = node-handle.advertise<message-type>(topic_name, queue_size);
*** Example: ros::Publisher pub = nh.advertise<geometry_msgs::Twist>("turtle1/cmd_vel",1000);
** ros::ok()
*** Check is the node is still in good standing, if the node received rosnodekill on ctrl+c this will results in a false condition. ros::init install the handle for this signal
** ros::shutdown()
*** Signal to the ROS that the node's work is complete from anywhere from the node code
** ros::Subscriber
*** Usage: ros::Subscriber subcriber-name = node-handle.subscribe(topics_name, queue_size, pointer_to_callback_function);
** ros::spinOnce()
*** Execute all the pending callbacks from all of the nodes subscription and return the control back
** ros::spin()
*** Wait for an execute the call till the node is shuts down
** ros::param::set (parameter_name, input_value);
*** Set the parameters from C++ code
** ros::param::get(parameter_name, output_value);
*** Get the parameter value from a c++ program
** Logging macro at various level in C++ style streams 
*** ROS_INFO_STREAM(message)
**** Generate an information stream from the node to multiple places in the ROS system including the console
**** Example: ROS_INFO_STREAM("Msg text" << "value1="<<class-member-value1 <<"value2="<<class-member-value2);
*** ROS_DEBUG_STREAM(message)
*** ROS_WARN_STREAM(message)
*** ROS_ERROR_STREAM(message)
*** ROS_FATAL_STREAM(message)
*** ROS_INFO_STREAM_ONCE(message)
*** ROS_DEBUG_STREAM_ONCE(message)
*** ROS_WARN_STREAM_ONCE(message)
*** ROS_ERROR_STREAM_ONCE(message)
*** ROS_FATAL_STREAM_ONCE(message)
*** ROS_INFO_STREAM_THROTTLE(internal, message)
**** interval is double and specify minimum time in seconds that must pass between successive instance of the given log message
*** ROS_DEBUG_STREAM_THROTTLE(interval, message)
*** ROS_WARN_STREAM_THROTTLE(interval, message)
*** ROS_ERROR_STREAM_THROTTLE(interval,  message)
*** ROS_FATAL_STREAM_THROTTLE(interval, message)
** stdbuf -oL command & >file-name
*** Pipe all the console output including erros and warning in order into the file file-name
*** See the file created above with less -r file-name to discard the ANSO colot prefix
*** rqt_logger_level : Set the logging level of the ROS system using a GUI
** ros::ServiceClient
*** Create an instance of a service client
*** Usage: ros::ServiceClient client = node_handler.serviceClient<service_type>(service_name, optional_bool_parameter_for persistent_client );
*** client.call(request, response) : this retirn a boolean with the resulting status, make sure to check this.
** ros::ServiceServer
*** Create an instance of a service server
*** Usage: ros::ServiceServer ss = node_handler.advertiseService(service_name, pointer_to_call_back_function);
*** We can alsoi use seperate thread to deal with performance issues in large systems at scale





**************Name Space (Graph Resource Name)***************
* Global Name space: starts with "/"
* Relative Name space: 
* Provate Name space" begins with "~"
* Anonymous name space: Reques a unique name to be assigned atomatically in ros::init
** Example: ros::init(argc,argv,base_name,ros::init_options::AnonymousName);
** This helps to run multiple instace of the same program without causing node-name conflict


***************ROS Launch File**************
* roslaunch 
** Usage: roslaunch package-name launch-file-name
** Addiiotnal argument
*** -v : verbose oiutput
** Enter Ctrl + c in the roslaunch terminal to shutdown all the nodes
** use the respawn= "true"  tag in the launch file to restart the node in case it terminates
** Use the required="true" to makse if this specifc node terminates everything else terminates as well
** Use launch-prefix="xterm -e" to launch each node on thier own terminal
** Use ns="namespace" to asign namespace to the node
**  Look into remapping names, this is useful in creating adapters that interpret the message differntly then originally intended
** group element can use a large number of node under the same namespace


*****************ROS Parameters******************
* rosparam
** Copmmands related to parameters
** rguments
*** list : List all existing parameters
*** get paramerter_name : Query parameter server for the value
*** get namespace : retrieve every parameter in a namespace
*** set parameter_name parameter_value : Set the parameter_name with the parameter_value
*** set namespace values : Set several parameter in a namespace
*** dump filename namespace : dump all the parameters from the namespace into a file filename
*** load filename namespace : Load all the parameters from the file filenmae into the namespace
* rosservice
** After setting the parameters to actually make it take effect by the nodes use this command
** rosservice call /clear
** Arguments
*** list : Display all current service that's running
*** node service-name : which node offers a given service
*** info service-name : Determine the type of the Service
*** call service-name request-content : call a service from command line

* rossrv
** Arguments
*** show nservice-data-type-nmae : Get details about a service types

* rosnode
** Arguments
*** info node-name : shoe what service is offerd by the node-name

* rosbag
**Recording a replyaing messages in ROS
** Arguments
*** record -O filename.bag topic-names  : Record message in filename.bag on the topic-name
*** record -a : Record every message , if file-name is not specified rosbag can choose a default filename to record the messages
*** record -j compress the bag files
*** play filename.bag 




*********Actuation Related Stuff****************************
* Locomote : Ability to moive around
** Differential Drive: This consists of two independently actuated wheele
** Casters Wheel: Un powered wheels, spins freely to support front or back of the robot
** Statically Stable : When viewed from above the center of mass of the robot is inside a polygon formed by the points of contacts between the wheels and the ground
** Dynamically Stable: Actuators must continuously be in mothing to preserve stability
** Sid-steering: Four and six wheels are possible, where all the wheels in each side actuate togather, wheels are also connected through external tracks like a tank
** Ackerman platfrom: The rear wheels are alwys pointed straigt ahead and the front wheels turn together, lioke in passenger cars. Disadvantage of this is they can't drive sideways
** Holonomic Platfroms: Wheels has two motors on that move backward and forward and the other steer arounf it's vertical axis
** Macanum wheels : For small smooth surface this wheels can be used to move in any direction
* Manipulator: Manipulate the objenct around like an Arm
** Pin Joints : Single axis revolute joints
** Prismatic Joints (Linear Joints): One link has a slide or tube along which the next link move
** Degree of Freedom (DOF): Typically the number of joints is equal to number of actuators. The DOF is one of the most significant
drivers of manip[ulators size, mass, dexterity, cost and reliability. Adding DOF to the distal (far) end of a robot arm typically increses
it's mass , which requires larger actuators on the proximal (near) joints, which further increase the mass of the manipulator
* Sensor: Make sense of the world through perception 
** Visual Camera:
*** Stereo Camera
*** In ROS the the following messages are used to manage image data
**** sensor_msgs::Image
**** sensor_msgs::CameraInfo : 
**** cv_bridge : This is used to interact with the OpenCV library an open source computer vision library
*** Depth Camera : Microsoft Kinect is a good example of this, it projects a structured light image and record the deformity and
use a reconstuction algorithm to create the 3D structure
*** Use the sensor_msgs::PointCloud2 message to interact with the data generated by the depth camera generated point cloud data which are 3D points estimated to lie on the srface facing camera
** Laser Scanner: In ROS laser scans are stored in sensor_msgs::LaserScan
** Shaft Encoder:This count how times the motors or wheel have turned and this information is used to estimates motions
*** Odometry information are most useful when reported as spatial transformation by a geometry_msgs::Transform message
*** Encoder reading for manipulator arms are bodcasted as sensor_msgs::JointState message

****************Simulation*************
* Gazebo
** ROS integrate closely with the gazebo_ros package

